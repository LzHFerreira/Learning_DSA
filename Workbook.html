<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>My Notes Guidebook</title>
  <style>
    body {
      font-family: sans-serif;
      margin: 2em;
      background: #121212;
      color: #e0e0e0;
    }
    h1 {
      color: #90caf9;
    }
    .toc {
      background: #1e1e1e;
      padding: 1em;
      border-radius: 8px;
      margin-bottom: 2em;
    }
    .toc a {
      display: block;
      margin: 0.3em 0;
      color: #64b5f6;
      text-decoration: none;
    }
    .section {
      margin-bottom: 1.5em;
      border: 1px solid #333;
      border-radius: 6px;
      background: #1e1e1e;
    }
    .section-header {
      background: #2c2c2c;
      padding: 0.8em;
      cursor: pointer;
      font-weight: bold;
      border-bottom: 1px solid #333;
    }
    .section-content {
      display: none;
      padding: 1em;
    }
    input[type="text"] {
      width: 100%;
      padding: 0.5em;
      margin-bottom: 1em;
      border: none;
      border-radius: 4px;
      background: #2c2c2c;
      color: #fff;
    }
    .hidden {
      display: none !important;
    }
  </style>
</head>
<body>

  <h1>📘 My Notes Guidebook</h1>

  <input type="text" id="searchBox" placeholder="🔍 Search notes..." onkeyup="searchNotes()">

  <div class="toc">
    <strong>📑 Table of Contents</strong>
    <a href="#DSA">DSA</a>
    <a href="#cloud">Cloud Fundamentals</a>
    <a href="#warehousing">Data Warehousing Fundamentals</a>
    <a href="#modeling">Data Modeling Fundamentals</a>
    <a href="#etl">ETL Fundamentals</a>
    <a href="#db">DB Fundamentals</a>
  </div>

  <div id="DSA" class="section">
    <div class="section-header" onclick="toggleSection(this)">DSA</div>
    <div class="section-content">
      
        <div class="section">

            <div class="section-header" onclick="toggleSection(this)">🔗 Doubly Linked List (Technical Essay)</div>
            <div class="section-content">
              <p>
                A <strong>doubly linked list</strong> is a linear data structure where each element (called a node) contains a value and two pointers:
                one pointing to the next node and another pointing to the previous node. This structure allows traversal in both directions.
              </p>
          
              <h4>📌 Why Use a Doubly Linked List?</h4>
              <p>
                Compared to arrays, doubly linked lists offer more flexible memory usage. They are easier to grow or shrink dynamically without reallocating or reorganizing memory.
                However, operations like insert, read, and delete have a time complexity of <code>O(n)</code> due to the need to traverse the list.
              </p>
          
              <h4>🧱 Node Structure</h4>
              <p>
                Each node is a simple object that stores a <code>value</code>, a reference to the <code>next</code> node, and a reference to the <code>prev</code> (previous) node.
              </p>
          
              <h4>🔧 Core Operations</h4>
              <ul>
                <li><strong>add_to_front(value)</strong>: Inserts a new node at the beginning of the list. If the list is empty, both <code>head</code> and <code>tail</code> point to the new node.</li>
                <li><strong>add_to_end(value)</strong>: Appends a new node at the end. If the list is empty, it behaves like <code>add_to_front</code>.</li>
                <li><strong>remove_from_front()</strong>: Removes the node at the head. Updates the head and handles the case where the list becomes empty.</li>
                <li><strong>remove_from_end()</strong>: Removes the node at the tail. Updates the tail and handles the empty list case.</li>
                <li><strong>find_from_head(value)</strong>: Traverses from the head to find a node with the given value.</li>
                <li><strong>find_from_tail(value)</strong>: Traverses from the tail to find a node with the given value.</li>
                <li><strong>remove_by_value(value)</strong>: Searches for a node with the given value and removes it, updating the surrounding links accordingly.</li>
              </ul>
          
              <h4>📎 Summary</h4>
              <p>
                This implementation demonstrates a foundational understanding of linked data structures. It includes robust handling of edge cases such as empty lists and single-node lists.
                The use of both <code>head</code> and <code>tail</code> pointers allows efficient additions at both ends.
              </p>
          
              <p>
                🔗 <a href="https://github.com/LzHFerreira/Learning_DSA/blob/main/Own_generated_codes/small_projects/sorted_list.py" target="_blank" style="color:#64b5f6;">View full code on GitHub</a>
              </p>
            </div>
          </div>
          
          <div class="section">
            <div class="section-header" onclick="toggleSection(this)">📋 Queue  (Technical Essay)</div>
            <div class="section-content">
              <p>
                A <strong>queue</strong> is a linear data structure that follows the <em>First-In-First-Out (FIFO)</em> principle. 
                This means that the first element added to the queue will be the first one to be removed, much like a line at a ticket counter.
              </p>
          
              <h4>📌 Why Use a Queue?</h4>
              <p>
                Queues are ideal for scenarios where order matters — such as task scheduling, print queues, or handling asynchronous events.
                Python’s <code>collections.deque</code> is a highly efficient double-ended queue that supports fast appends and pops from both ends.
              </p>
          
              <h4>🧱 Queue Implementation</h4>
              <p>
                The <code>MyQueue</code> class wraps a <code>deque</code> object and provides typical queue operations:
              </p>
              <ul>
                <li><strong>enqueue(item)</strong>: Adds an item to the rear of the queue.</li>
                <li><strong>dequeue()</strong>: Removes and returns the item at the front. Raises an error if the queue is empty.</li>
                <li><strong>is_empty()</strong>: Checks whether the queue is empty.</li>
                <li><strong>size()</strong>: Returns the number of items in the queue.</li>
                <li><strong>peek()</strong>: Returns the front item without removing it.</li>
                <li><strong>rear()</strong>: Returns the last item without removing it (making it behave like a deque).</li>
              </ul>
          
              <h4>⚙️ Task Scheduling System</h4>
              <p>
                The <code>Tasks</code> class simulates a basic task scheduling system using Python’s built-in <code>Queue</code> class.
                It supports:
              </p>
              <ul>
                <li><strong>add_task(task)</strong>: Adds a task to the queue.</li>
                <li><strong>execute_task()</strong>: Executes (removes and returns) the next task in line. Raises an error if the queue is empty.</li>
                <li><strong>is_empty()</strong>: Checks if there are any tasks left.</li>
                <li><strong>task_count()</strong>: Returns the number of tasks currently in the queue.</li>
              </ul>
          
              <h4>🖥️ CLI Interaction</h4>
              <p>
                The script includes a simple command-line interface (CLI) that allows users to:
              </p>
              <ul>
                <li>Add tasks</li>
                <li>Execute tasks</li>
                <li>Check how many tasks are pending</li>
                <li>Quit the program</li>
              </ul>
              <p>
                This interactive loop demonstrates how queues can be used in real-world applications like job schedulers or background task managers.
              </p>
          
              <p>
                🔗 <a href="https://github.com/LzHFerreira/Learning_DSA/blob/main/Own_generated_codes/small_projects/scheduling_tasks.py" target="_blank" style="color:#64b5f6;">View full code on GitHub</a>
              </p>
            </div>
          </div>

          <div class="section">
            <div class="section-header" onclick="toggleSection(this)">🧱 Stack</div>
            <div class="section-content">
              <p>
                A <strong>stack</strong> is a linear data structure that follows the <em>Last-In-First-Out (LIFO)</em> principle. 
                This means the most recently added item is the first to be removed — like a stack of plates.
              </p>
          
              <h4>📌 Why Use a Stack?</h4>
              <p>
                Stacks are ideal for scenarios where you need to reverse operations or maintain a history of actions — such as undo/redo functionality, expression evaluation, or backtracking algorithms.
                Python’s built-in <code>list</code> type provides an efficient way to implement a stack using <code>append()</code> and <code>pop()</code>.
              </p>
          
              <h4>🧱 Stack Implementation</h4>
              <p>
                The <code>Stack</code> class provides a simple interface for stack operations:
              </p>
              <ul>
                <li><strong>push(item)</strong>: Adds an item to the top of the stack.</li>
                <li><strong>pop()</strong>: Removes and returns the top item. Raises an error if the stack is empty.</li>
                <li><strong>peek()</strong>: Returns the top item without removing it.</li>
                <li><strong>is_empty()</strong>: Checks whether the stack is empty.</li>
                <li><strong>size()</strong>: Returns the number of items in the stack.</li>
              </ul>
          
              <h4>🔁 Undo/Redo System</h4>
              <p>
                The <code>PerformActions</code> class builds on the stack concept to simulate an undo/redo system:
              </p>
              <ul>
                <li><strong>client_action(action)</strong>: Logs a new action and clears the redo history.</li>
                <li><strong>undo()</strong>: Pops the last action from the performed stack and pushes it to the redo stack.</li>
                <li><strong>redo()</strong>: Pops the last undone action and re-applies it.</li>
                <li><strong>show_actions()</strong>: Displays the current and undone actions for visibility.</li>
              </ul>
          
              <h4>🖥️ CLI Interaction</h4>
              <p>
                The script includes a command-line interface that allows users to:
              </p>
              <ul>
                <li>Perform actions</li>
                <li>Undo and redo actions</li>
                <li>View the current state of the action stack</li>
                <li>Quit the program</li>
              </ul>
              <p>
                This is a practical demonstration of how stacks can be used to manage state history in real-world applications like text editors, drawing tools, or command-based systems.
              </p>
          
              <p>
                🔗 <a href="https://github.com/LzHFerreira/Learning_DSA/blob/main/Own_generated_codes/small_projects/undoing_and_redoing_things.py" target="_blank" style="color:#64b5f6;">View full code on GitHub</a>
              </p>
            </div>
          </div>

          <div class="section">
            <div class="section-header" onclick="toggleSection(this)">🌳 Binary Tree (Technical Essay)</div>
            <div class="section-content">
              <p>
                A <strong>binary tree</strong> is a hierarchical data structure in which each node has at most two children, referred to as the <em>left</em> and <em>right</em> child.
                Binary trees are foundational in computer science and are used in a wide range of applications such as expression parsing, search trees, and decision-making systems.
              </p>
          
              <h4>📌 Structure</h4>
              <p>
                Each node in the tree contains a value and pointers to its left and right children. The tree starts with a <code>root</code> node, and all other nodes branch from it.
              </p>
          
              <h4>🌱 Insertion</h4>
              <p>
                The <code>insert()</code> method places new values into the tree following the binary search tree (BST) property:
                values less than the current node go to the left, and values greater or equal go to the right.
              </p>
          
              <h4>🔍 Searching</h4>
              <p>
                The <code>search()</code> method uses a recursive approach to locate a value in the tree, starting from the root and traversing left or right depending on the comparison.
              </p>
          
              <h4>🧭 Traversal Methods</h4>
              <ul>
                <li><strong>Pre-order</strong>: Visit the node, then traverse left and right. Useful for copying the tree.</li>
                <li><strong>In-order</strong>: Traverse left, visit the node, then traverse right. Produces sorted output in BSTs.</li>
                <li><strong>Post-order</strong>: Traverse left and right, then visit the node. Useful for deleting the tree.</li>
              </ul>
          
              <h4>🔎 Search Strategies</h4>
              <ul>
                <li><strong>Depth-First Search (DFS)</strong>: Recursively explores as far as possible along each branch before backtracking. Implemented using recursion.</li>
                <li><strong>Breadth-First Search (BFS)</strong>: Explores all nodes at the present depth before moving to the next level. Implemented using a queue (<code>deque</code>).</li>
              </ul>
          
              <h4>🧪 Example Usage</h4>
                    <p>
  In this implementation, the binary tree is used as a <strong>decision tree classifier</strong> for domestic animals.
  Each internal node represents a question (e.g., “Is it a mammal?”), and each leaf node represents a classification result (e.g., “Dog”, “Cat”).
</p>
<p>
  The script includes a <strong>command-line interface (CLI)</strong> that allows users to:
</p>
<ul>
  <li>Visualize the structure of the decision tree</li>
  <li>Interactively classify an animal by answering yes/no questions</li>
  <li>Exit the program</li>
</ul>
<p>
  This example demonstrates how binary trees can be applied to real-world problems like decision-making and classification systems.
</p>

              <p>
                🔗 <a href="https://github.com/LzHFerreira/Learning_DSA/blob/main/Own_generated_codes/small_projects/domestic_animal_classifier.py" target="_blank" style="color:#64b5f6;">View full code on GitHub</a>
              </p>
            </div>
          </div>
          
          <div class="section">
            <div class="section-header" onclick="toggleSection(this)">🔐 Hash Map  (Technical Essay)</div>
            <div class="section-content">
              <p>
                A <strong>hash map</strong> (or dictionary in Python) is a data structure that stores key-value pairs and allows for fast retrieval, insertion, and deletion of values based on keys.
                It uses a hash function to compute an index into an array of buckets or slots, from which the desired value can be found.
              </p>
          
              <h4>📌 Why Use a Hash Map?</h4>
              <p>
                Hash maps provide <code>O(1)</code> average time complexity for lookups, insertions, and deletions, making them ideal for scenarios where fast access to data is critical.
                Python’s built-in <code>dict</code> type is a highly optimized hash map implementation.
              </p>
          
              <h4>🧱 HashMap Class Overview</h4>
              <p>
                The <code>HashMap</code> class wraps Python’s dictionary and provides a simplified interface:
              </p>
              <ul>
                <li><strong>put(key, value)</strong>: Stores a value under a specific key.</li>
                <li><strong>get(key)</strong>: Retrieves the value for a given key, or <code>None</code> if not found.</li>
                <li><strong>remove(key)</strong>: Deletes the key-value pair if it exists.</li>
                <li><strong>contains(key)</strong>: Checks if a key exists in the map.</li>
                <li><strong>keys()</strong>, <strong>values()</strong>, <strong>items()</strong>: Return lists of keys, values, or key-value pairs.</li>
              </ul>
          
              <h4>🏨 Hotel Message System</h4>
              <p>
                The real-world application of this concept is demonstrated in a <strong>hotel message system</strong>, where messages are stored and retrieved based on the first letter of a guest’s last name.
                This simulates a dovecot cupboard system, where each letter (A-Z) represents a slot.
              </p>
          
              <h4>🔧 System Features</h4>
              <ul>
                <li><strong>add_message()</strong>: Adds a message for a guest, categorized by the first letter of their last name.</li>
                <li><strong>get_messages()</strong>: Retrieves all messages for a specific guest.</li>
                <li><strong>remove_messages()</strong>: Deletes all messages for a guest after retrieval.</li>
              </ul>
          
              <h4>🖥️ CLI Interaction</h4>
              <p>
                The script includes a command-line interface that allows hotel staff or guests to:
              </p>
              <ul>
                <li>Leave a message for a guest</li>
                <li>Check and retrieve messages</li>
                <li>Exit the system</li>
              </ul>
              <p>
                This example shows how hash maps can be used to efficiently organize and access categorized data in a user-friendly system.
              </p>
          
              <p>
                🔗 <a href="https://github.com/LzHFerreira/Learning_DSA/blob/main/Own_generated_codes/small_projects/searching_for_messages.py" target="_blank" style="color:#64b5f6;">View full code on GitHub</a>
              </p>
            </div>
          </div>
          
          <div class="section">
            <div class="section-header" onclick="toggleSection(this)">🔍 Sorting and Searching Algorithms</div>
            <div class="section-content">
          
              <div class="section">
                <div class="section-header" onclick="toggleSection(this)">🫧 Bubble Sort (Technical Essay)</div>
                <div class="section-content">
                  <p>
                    <strong>Bubble Sort</strong> is a simple, comparison-based sorting algorithm. It works by repeatedly stepping through the list,
                    comparing adjacent elements, and swapping them if they are in the wrong order. This process continues until the list is sorted.
                  </p>
          
                  <h4>📌 How It Works</h4>
                  <p>
                    On each pass through the list, the largest unsorted element "bubbles up" to its correct position at the end.
                    With each iteration, the unsorted portion of the list becomes smaller.
                  </p>
          
                  <h4>⏱️ Time & Space Complexity</h4>
                  <ul>
                    <li><strong>Worst-case:</strong> <code>O(n²)</code></li>
                    <li><strong>Best-case:</strong> <code>O(n)</code> (when already sorted, with optimization)</li>
                    <li><strong>Average-case:</strong> <code>O(n²)</code></li>
                    <li><strong>Space:</strong> <code>O(1)</code> (in-place sorting)</li>
                  </ul>
          
                  <h4>🧠 Why Use Bubble Sort?</h4>
                  <ul>
                    <li>Great for educational purposes to demonstrate sorting logic</li>
                    <li>Simple to implement and understand</li>
                    <li>Useful for small datasets where performance is not critical</li>
                    <li>In-place sorting with minimal memory usage</li>
                  </ul>
          
                  <h4>🧪 Example Usage</h4>
                  <p>
                    The implementation demonstrates sorting of integers, floats, and strings. It includes an optimization to exit early if no swaps occur during a pass, improving best-case performance.
                  </p>
          
                  <p>
                    🔗 <a href="https://github.com/LzHFerreira/Learning_DSA/blob/main/Sorting_and_searching(AI_Generated)/bubble_sort.py" target="_blank" style="color:#64b5f6;">View full code on GitHub</a>
                  </p>
                </div>

              </div>

              <div class="section">
                <div class="section-header" onclick="toggleSection(this)">⚡ Quicksort (Technical Essay)</div>
                <div class="section-content">
                  <p>
                    <strong>Quicksort</strong> is a highly efficient <em>divide-and-conquer</em> sorting algorithm. It works by selecting a pivot element and partitioning the list into two sublists:
                    one with elements less than the pivot and one with elements greater. These sublists are then sorted recursively.
                  </p>
              
                  <h4>📌 How It Works</h4>
                  <p>
                    The algorithm chooses a pivot (commonly the last element), then rearranges the list so that all elements less than the pivot come before it,
                    and all elements greater come after. This process is repeated recursively on the sublists.
                  </p>
              
                  <h4>⏱️ Time & Space Complexity</h4>
                  <ul>
                    <li><strong>Worst-case:</strong> <code>O(n²)</code> (e.g., when the smallest or largest element is always chosen as pivot)</li>
                    <li><strong>Best-case:</strong> <code>O(n log n)</code> (when pivot divides the list evenly)</li>
                    <li><strong>Average-case:</strong> <code>O(n log n)</code></li>
                    <li><strong>Space:</strong> <code>O(log n)</code> (due to recursive stack)</li>
                  </ul>
              
                  <h4>🧠 Why Use Quicksort?</h4>
                  <ul>
                    <li>Often faster in practice than other <code>O(n log n)</code> algorithms due to in-place sorting and cache efficiency</li>
                    <li>Widely used in standard libraries and real-world applications</li>
                    <li>Not stable (equal elements may change order)</li>
                    <li>Not ideal for linked lists or when stability is required</li>
                  </ul>
              
                  <h4>🧪 Example Usage</h4>
                  <p>
                    The implementation demonstrates sorting of integers, floats, and strings. It uses a simple pivot strategy (last element) and handles duplicates by grouping equal values.
                    The function returns a new sorted list, preserving the original input.
                  </p>
              
                  <p>
                    🔗 <a href="https://github.com/LzHFerreira/Learning_DSA/blob/main/Sorting_and_searching(AI_Generated)/quicksort.py" target="_blank" style="color:#64b5f6;">View full code on GitHub</a>
                  </p>
                </div>
              </div>
              
              <div class="section">
                <div class="section-header" onclick="toggleSection(this)">📥 Insertion Sort (Technical Essay)</div>
                <div class="section-content">
                  <p>
                    <strong>Insertion Sort</strong> is a simple and intuitive sorting algorithm that builds the final sorted list one item at a time.
                    It works by taking each element from the unsorted portion and inserting it into its correct position in the sorted portion.
                  </p>
              
                  <h4>📌 How It Works</h4>
                  <p>
                    Starting from the second element, the algorithm compares it with the elements before it and shifts larger elements one position to the right
                    to make space for the current element. This process continues until the entire list is sorted.
                  </p>
              
                  <h4>⏱️ Time & Space Complexity</h4>
                  <ul>
                    <li><strong>Worst-case:</strong> <code>O(n²)</code> (e.g., reverse sorted list)</li>
                    <li><strong>Best-case:</strong> <code>O(n)</code> (already sorted list)</li>
                    <li><strong>Average-case:</strong> <code>O(n²)</code></li>
                    <li><strong>Space:</strong> <code>O(1)</code> (in-place sorting)</li>
                  </ul>
              
                  <h4>🧠 Why Use Insertion Sort?</h4>
                  <ul>
                    <li>Stable sort (preserves order of equal elements)</li>
                    <li>Adaptive (performs well on nearly sorted data)</li>
                    <li>Simple to implement and understand</li>
                    <li>Useful for small datasets or as part of hybrid algorithms like TimSort</li>
                    <li>Supports online sorting (can sort as new elements arrive)</li>
                  </ul>
              
                  <h4>🧪 Example Usage</h4>
                  <p>
                    The implementation demonstrates sorting of integers, floats, and strings. It performs in-place sorting, modifying the original list directly.
                    This makes it memory-efficient and ideal for constrained environments.
                  </p>
              
                  <p>
                    🔗 <a href="https://github.com/LzHFerreira/Learning_DSA/blob/main/Sorting_and_searching(AI_Generated)/insertion_sort.py" target="_blank" style="color:#64b5f6;">View full code on GitHub</a>
                  </p>
                </div>
              </div>
              
              <div class="section">
                <div class="section-header" onclick="toggleSection(this)">🧩 Merge Sort (Technical Essay)</div>
                <div class="section-content">
                  <p>
                    <strong>Merge Sort</strong> is a classic <em>divide-and-conquer</em> sorting algorithm. It works by dividing the list into halves,
                    recursively sorting each half, and then merging the sorted halves to produce the final sorted list.
                  </p>
              
                  <h4>📌 How It Works</h4>
                  <p>
                    The algorithm breaks the problem into smaller subproblems (divide), solves each recursively (conquer),
                    and then combines the results (merge). This makes it highly efficient and predictable in performance.
                  </p>
              
                  <h4>⏱️ Time & Space Complexity</h4>
                  <ul>
                    <li><strong>Worst-case:</strong> <code>O(n log n)</code></li>
                    <li><strong>Best-case:</strong> <code>O(n log n)</code></li>
                    <li><strong>Average-case:</strong> <code>O(n log n)</code></li>
                    <li><strong>Space:</strong> <code>O(n)</code> (requires additional space for merging)</li>
                  </ul>
              
                  <h4>🧠 Why Use Merge Sort?</h4>
                  <ul>
                    <li>Stable sort (preserves order of equal elements)</li>
                    <li>Efficient for large datasets</li>
                    <li>Ideal for external sorting (e.g., data that doesn’t fit in memory)</li>
                    <li>Commonly used in hybrid algorithms like Python’s TimSort</li>
                    <li>Works well with linked lists (no need for random access)</li>
                  </ul>
              
                  <h4>🧪 Example Usage</h4>
                  <p>
                    The implementation demonstrates sorting of integers, floats, and strings. Unlike in-place algorithms, Merge Sort returns a new sorted list,
                    making it suitable for functional-style programming or when immutability is preferred.
                  </p>
              
                  <p>
                    🔗 <a href="https://github.com/LzHFerreira/Learning_DSA/blob/main/Sorting_and_searching(AI_Generated)/merge_sort.py" target="_blank" style="color:#64b5f6;">View full code on GitHub</a>
                  </p>
                </div>
              </div>
              
              <div class="section">
                <div class="section-header" onclick="toggleSection(this)">🔎 Linear Search (Technical Essay)</div>
                <div class="section-content">
                  <p>
                    <strong>Linear Search</strong>, also known as <em>Sequential Search</em>, is the most straightforward searching algorithm.
                    It checks each element in a list one by one until the target is found or the list ends.
                  </p>
              
                  <h4>📌 How It Works</h4>
                  <p>
                    The algorithm iterates through the list from start to finish. If it finds the target element, it returns its index.
                    If it reaches the end without finding the target, it returns <code>-1</code>.
                  </p>
              
                  <h4>⏱️ Time & Space Complexity</h4>
                  <ul>
                    <li><strong>Worst-case:</strong> <code>O(n)</code> (target is at the end or not present)</li>
                    <li><strong>Best-case:</strong> <code>O(1)</code> (target is the first element)</li>
                    <li><strong>Average-case:</strong> <code>O(n)</code></li>
                    <li><strong>Space:</strong> <code>O(1)</code> (no extra memory used)</li>
                  </ul>
              
                  <h4>🧠 Why Use Linear Search?</h4>
                  <ul>
                    <li>Works on unsorted data</li>
                    <li>Simple to implement and understand</li>
                    <li>Useful for small datasets or quick checks</li>
                    <li>Can be used on any iterable (lists, arrays, etc.)</li>
                  </ul>
              
                  <h4>🧪 Example Usage</h4>
                  <p>
                    The implementation demonstrates searching for integers and strings. It returns the index of the target if found, or <code>-1</code> if not.
                    This makes it ideal for small or unsorted collections where performance is not a concern.
                  </p>
              
                  <p>
                    🔗 <a href="https://github.com/LzHFerreira/Learning_DSA/blob/main/Sorting_and_searching(AI_Generated)/linear_search.py" target="_blank" style="color:#64b5f6;">View full code on GitHub</a>
                  </p>
                </div>
              </div>

              <div class="section">
                <div class="section-header" onclick="toggleSection(this)">📐 Binary Search (Technical Essay)</div>
                <div class="section-content">
                  <p>
                    <strong>Binary Search</strong> is an efficient algorithm for finding an item in a <em>sorted</em> list.
                    It works by repeatedly dividing the search interval in half and comparing the target value to the middle element.
                  </p>
              
                  <h4>📌 How It Works</h4>
                  <p>
                    If the target is equal to the middle element, the search is complete. If the target is less, the search continues in the left half;
                    if greater, it continues in the right half. This process repeats until the target is found or the interval is empty.
                  </p>
              
                  <h4>⏱️ Time & Space Complexity</h4>
                  <ul>
                    <li><strong>Worst-case:</strong> <code>O(log n)</code></li>
                    <li><strong>Best-case:</strong> <code>O(1)</code> (target is at the middle)</li>
                    <li><strong>Average-case:</strong> <code>O(log n)</code></li>
                    <li><strong>Space:</strong> <code>O(1)</code> for iterative version, <code>O(log n)</code> for recursive version</li>
                  </ul>
              
                  <h4>🧠 Why Use Binary Search?</h4>
                  <ul>
                    <li>Much faster than linear search for large, sorted datasets</li>
                    <li>Widely used in databases, libraries, and search engines</li>
                    <li>Requires sorted input data</li>
                    <li>Simple to implement and highly efficient</li>
                  </ul>
              
                  <h4>🧪 Example Usage</h4>
                  <p>
                    The implementation demonstrates searching for integers and strings in sorted lists. It returns the index of the target if found, or <code>-1</code> if not.
                    This makes it ideal for fast lookups in sorted collections.
                  </p>
              
                  <p>
                    🔗 <a href="https://github.com/LzHFerreira/Learning_DSA/blob/main/Sorting_and_searching(AI_Generated)/binary_search.py" target="_blank" style="color:#64b5f6;">View full code on GitHub</a>
                  </p>
                </div>
              </div>
              


            </div>
          </div>
          
          <div class="section">
            <div class="section-header" onclick="toggleSection(this)">🧵 String Searching Algorithms</div>
            <div class="section-content">
          
              <div class="section">
                <div class="section-header" onclick="toggleSection(this)">🔍 Naive String Search (Technical Essay)</div>
                <div class="section-content">
                  <p>
                    <strong>Naive String Search</strong>, also known as <em>brute force search</em>, is the simplest method for finding a substring (pattern) within a larger string (text).
                    It checks every possible position in the text where the pattern could match.
                  </p>
          
                  <h4>📌 How It Works</h4>
                  <p>
                    The algorithm slides the pattern over the text one character at a time. At each position, it compares the pattern to the substring of the text.
                    If all characters match, the starting index is recorded. This continues until the end of the text is reached.
                  </p>
          
                  <h4>⏱️ Time & Space Complexity</h4>
                  <ul>
                    <li><strong>Worst-case:</strong> <code>O(n * m)</code> (where <code>n</code> is the text length and <code>m</code> is the pattern length)</li>
                    <li><strong>Best-case:</strong> <code>O(n)</code> (pattern found early)</li>
                    <li><strong>Space:</strong> <code>O(1)</code> (no extra memory used)</li>
                  </ul>
          
                  <h4>🧠 Why Use Naive Search?</h4>
                  <ul>
                    <li>Very simple to implement</li>
                    <li>Works on any text and pattern without preprocessing</li>
                    <li>Useful for small inputs or educational purposes</li>
                    <li>Not efficient for large texts or complex patterns</li>
                  </ul>
          
                  <h4>🧪 Example Usage</h4>
                  <p>
                    The implementation demonstrates searching for patterns in various texts, including overlapping matches.
                    It returns a list of starting indices where the pattern occurs in the text.
                  </p>
          
                  <p>
                    🔗 <a href="https://github.com/LzHFerreira/Learning_DSA/blob/main/String_Searching(AI_Generated)/naive_search.py" target="_blank" style="color:#64b5f6;">View full code on GitHub</a>
                  </p>
                </div>
              </div>
              
              <div class="section">
                <div class="section-header" onclick="toggleSection(this)">🚀 Boyer-Moore String Search (Technical Essay)</div>
                  <div class="section-content">
                    <p><strong>Boyer-Moore</strong> is a highly efficient string searching algorithm that significantly reduces the number of comparisons
                    by preprocessing the pattern and using that information to skip sections of the text.
                    </p>

    <h4>📌 How It Works</h4>
    <p>
      The algorithm uses two main heuristics: the <em>bad character rule</em> and the <em>good suffix rule</em>.
      This implementation uses the bad character rule, which shifts the pattern based on the last occurrence of a mismatched character.
      This allows the algorithm to skip over large portions of the text, especially when mismatches occur near the end of the pattern.
    </p>

    <h4>⏱️ Time & Space Complexity</h4>
    <ul>
      <li><strong>Worst-case:</strong> <code>O(n * m)</code> (rare, with specific patterns)</li>
      <li><strong>Best/average-case:</strong> <code>O(n)</code> (often sublinear in practice)</li>
      <li><strong>Space:</strong> <code>O(m + k)</code> (for pattern length <code>m</code> and alphabet size <code>k</code>)</li>
    </ul>

    <h4>🧠 Why Use Boyer-Moore?</h4>
    <ul>
      <li>Extremely fast for large texts and patterns</li>
      <li>Widely used in real-world applications (e.g., text editors, search engines)</li>
      <li>Efficient even with partial matches and mismatches</li>
      <li>Forms the basis of many advanced search tools</li>
    </ul>

    <h4>🧪 Example Usage</h4>
    <p>
      The implementation demonstrates searching for patterns in various texts, including multiple matches and cases where the pattern is not found.
      It returns a list of starting indices where the pattern occurs in the text.
    </p>

    <p>
      🔗 <a href="https://github.com/LzHFerreira/Learning_DSA/blob/main/String_Searching(AI_Generated)/Boyer-Moore.py" target="_blank" style="color:#64b5f6;">View full code on GitHub</a>
    </p>
  </div>
</div>


            </div>
          </div>
          
          <div class="section">
            <div class="section-header" onclick="toggleSection(this)">🌲 Balanced Binary Trees</div>
            <div class="section-content">
          
              <div class="section">
                <div class="section-header" onclick="toggleSection(this)">⚖️ AVL Tree (Technical Essay)</div>
                <div class="section-content">
                  <p>
                    An <strong>AVL Tree</strong> is a self-balancing binary search tree (BST) where the difference in height between the left and right subtrees
                    of any node is at most 1. This balance is maintained through rotations during insertions and deletions.
                  </p>
          
                  <h4>📌 How It Works</h4>
                  <p>
                    Each node in an AVL tree stores its height. After every insertion or deletion, the tree checks whether it is still balanced.
                    If not, it performs one of four types of rotations to restore balance:
                  </p>
                  <ul>
                    <li><strong>Left Rotation</strong></li>
                    <li><strong>Right Rotation</strong></li>
                    <li><strong>Left-Right Rotation</strong></li>
                    <li><strong>Right-Left Rotation</strong></li>
                  </ul>
          
                  <h4>⏱️ Time & Space Complexity</h4>
                  <ul>
                    <li><strong>Search:</strong> <code>O(log n)</code></li>
                    <li><strong>Insertion:</strong> <code>O(log n)</code></li>
                    <li><strong>Deletion:</strong> <code>O(log n)</code></li>
                    <li><strong>Space:</strong> <code>O(n)</code></li>
                  </ul>
          
                  <h4>🧠 Why Use AVL Trees?</h4>
                  <ul>
                    <li>Guarantees balanced structure for consistent performance</li>
                    <li>Ideal for applications requiring frequent insertions and deletions</li>
                    <li>Ensures logarithmic time complexity for all operations</li>
                  </ul>
          
                  <h4>🧪 Example Usage</h4>
                  <p>
                    AVL trees are commonly used in databases, file systems, memory management, and indexing systems where fast and balanced access is critical.
                  </p>
          
                  <p>
                    🔗 <a href="https://github.com/LzHFerreira/Learning_DSA/blob/main/Balanced_Binary_Tree(AI_Generated)/AVL_Tree.py" target="_blank" style="color:#64b5f6;">View full code on GitHub</a>
                  </p>
                </div>
              </div>
          
            </div>
          </div>
          
          <div class="section">
            <div class="section-header" onclick="toggleSection(this)">🔣 Sets and Set Algorithms</div>
            <div class="section-content">
          
              <div class="section">
                <div class="section-header" onclick="toggleSection(this)">🧮 Python Set Operations (Technical Essay)</div>
                <div class="section-content">
                  <p>
                    A <strong>set</strong> in Python is an unordered collection of unique elements. Sets are implemented using hash tables,
                    which allow for fast membership testing and efficient set operations like union, intersection, and difference.
                  </p>
          
                  <h4>📌 How It Works</h4>
                  <p>
                    Sets support mathematical operations and are ideal for tasks involving uniqueness, fast lookups, and comparisons between collections.
                    Python provides built-in operators and methods for all common set operations.
                  </p>
          
                  <h4>⏱️ Time & Space Complexity</h4>
                  <ul>
                    <li><strong>Membership test:</strong> <code>O(1)</code> average</li>
                    <li><strong>Add/remove element:</strong> <code>O(1)</code> average</li>
                    <li><strong>Union, intersection, difference:</strong> <code>O(len(s) + len(t))</code></li>
                    <li><strong>Space:</strong> <code>O(n)</code> (where <code>n</code> is the number of elements)</li>
                  </ul>
          
                  <h4>🧠 Why Use Sets?</h4>
                  <ul>
                    <li>Remove duplicates from a list</li>
                    <li>Perform fast membership testing</li>
                    <li>Execute mathematical set operations</li>
                    <li>Compare collections for common or unique elements</li>
                  </ul>
          
                  <h4>🧪 Example Usage</h4>
                  <p>
                    The implementation demonstrates union, intersection, difference, symmetric difference, subset/superset checks, and membership testing.
                    It also shows how to remove duplicates from a list using a set.
                  </p>
          
                  <p>
                    🔗 <a href="https://github.com/LzHFerreira/Learning_DSA/blob/main/Sets_and_sets_algorithms/sets_and_sets_algorithms.py" target="_blank" style="color:#64b5f6;">View full code on GitHub</a>
                  </p>
                </div>
              </div>
          
            </div>
          </div>
          
          
    </div>
  </div>
  

  <div id="cloud" class="section">
    <div class="section-header" onclick="toggleSection(this)">Cloud Fundamentals</div>
    <div class="section-content">
      <p>Concepts like IaaS, PaaS, SaaS, cloud providers, and deployment models.</p>
    </div>
  </div>

  <div id="warehousing" class="section">
    <div class="section-header" onclick="toggleSection(this)">Data Warehousing Fundamentals</div>
    <div class="section-content">
      <p>Topics like OLAP vs OLTP, star/snowflake schemas, and data marts.</p>
    </div>
  </div>

  <div id="modeling" class="section">
    <div class="section-header" onclick="toggleSection(this)">Data Modeling Fundamentals</div>
    <div class="section-content">
      <p>ER diagrams, normalization, relationships, and dimensional modeling.</p>
    </div>
  </div>

  <div id="etl" class="section">
    <div class="section-header" onclick="toggleSection(this)">ETL Fundamentals</div>
    <div class="section-content">
      <p>Extract, Transform, Load processes, tools, and best practices.</p>
    </div>
  </div>

  <div id="db" class="section">
    <div class="section-header" onclick="toggleSection(this)">DB Fundamentals</div>
    <div class="section-content">
      <p>SQL basics, indexing, transactions, ACID properties, and DBMS types.</p>
    </div>
  </div>

  <script>
    function toggleSection(header) {
      const content = header.nextElementSibling;
      content.style.display = content.style.display === 'block' ? 'none' : 'block';
    }

    function searchNotes() {
      const query = document.getElementById('searchBox').value.toLowerCase();
      const sections = document.querySelectorAll('.section');

      sections.forEach(section => {
        const content = section.querySelector('.section-content');
        const text = content.textContent.toLowerCase();
        if (text.includes(query)) {
          section.classList.remove('hidden');
        } else {
          section.classList.add('hidden');
        }
      });
    }
  </script>

</body>
</html>
